/* conditional-tag v1.0.0
https://github.com/VividVisions/conditional-tag */
const t=Symbol("condTrue"),i=Symbol("condFalse");function s(s){return{func:"if",cond:s?t:i}}function e(s){return{func:"elseif",cond:s?t:i}}const n=Symbol("else"),r=Symbol("endif");class h extends Error{}class c{static steps={NEUTRAL:0,IF:1,ELSEIF:2,ELSE:3};withinIf;anyCondMet;step;constructor(){this.#t()}#t(){this.withinIf=!1,this.anyCondMet=!1,this.step=c.NEUTRAL}#i(t){return"if"===t?.func&&(this.#s(t?.cond)||this.#e(t?.cond))}#n(t){return"elseif"===t?.func&&(this.#s(t?.cond)||this.#e(t?.cond))}#r(t){return t===n}#h(t){return t===r}#s(i){return i===t}#e(t){return t===i}canHandle(t){return this.#i(t)||this.#n(t)||this.#r(t)||this.#h(t)}handle(t,i){if(this.#i(t)){if(this.withinIf)throw new h("Only one _if() permitted per if-block.");this.anyCondMet=this.#s(t.cond),i.filterOut=!this.anyCondMet,this.step=c.steps.IF,this.withinIf=!0}else if(this.#n(t)){if(!this.withinIf)throw new h("_elseif() must be inside if-block.");if(this.step>c.steps.ELSEIF)throw new h("_elseif() must not occur after _else.");this.step=c.steps.ELSEIF,this.anyCondMet?i.filterOut=!0:(this.anyCondMet=this.#s(t.cond),i.filterOut=!this.anyCondMet)}else if(this.#r(t)){if(!this.withinIf)throw new h("_else must be inside if-block.");if(this.step>c.steps.ELSEIF)throw new h("Only one _else permitted per if-block.");this.step=c.steps.ELSE,this.anyCondMet?i.filterOut=!0:(i.filterOut=!1,this.anyCondMet=!0)}else if(this.#h(t)){if(!this.withinIf)throw new h("_endif must be inside if-block.");this.#t(),i.filterOut=!1}return!1}}const o=Symbol("switch"),f=Symbol("case"),l=Symbol("switchCase");function a(t){return{func:o,switchVar:t,_case:y(t)}}function u(...t){return{func:f,caseVars:t}}const d=Symbol("default"),w=Symbol("endswitch");function y(t){return function(...i){return{func:l,switchVar:t,caseVars:i}}}class C{switchVar;anyCondMet;constructor(){this.#t()}#t(){this.switchVar=void 0,this.anyCondMet=!1}#c(t){return t?.func===o}#o(t){return t?.func===f}#f(t){return t?.func===l}#l(t){return t===d}#a(t){return t===w}canHandle(t){return this.#c(t)||this.#o(t)||this.#f(t)||this.#l(t)||this.#a(t)}handle(t,i){if(this.#c(t)){if(void 0!==this.switchVar)throw new h("Only one _switch() permitted per switch-block.");this.switchVar=t.switchVar}else if(this.#f(t)){if(void 0!==this.switchVar)throw new h("Only one _switch() permitted per switch-block.");this.switchVar=t.switchVar,t.func=f}if(this.#o(t)){if(void 0===this.switchVar)throw new h("_case() must be inside switch-block.");t.caseVars.some((t=>t===this.switchVar))?(this.anyCondMet=!0,i.filterOut=!1):i.filterOut=!0}else if(this.#l(t)){if(void 0===this.switchVar)throw new h("_default must be inside switch-block.");i.filterOut=this.anyCondMet}else if(this.#a(t)){if(void 0===this.switchVar)throw new h("_endswitch must be inside switch-block");i.filterOut=!1,this.#t()}return!1}}const E=Symbol("always");class S{#u(t){return t===E}canHandle(t){return this.#u(t)}handle(t,i){return i.filterOut=!1,!1}}const b=/(^|\r?\n)[^\S\r\n]*$/,p=/^[^\S\r\n]*(\r?\n|$)/;function m(t,...i){const s=new c,e=new C,n=new S,r={filterOut:!1},h=t.flatMap(((t,s)=>s<i.length?[t,i[s]]:t)),o=new Set;let f=0;const l=h.filter(((t,i)=>{if("string"!=typeof t){if(s.canHandle(t))return o.add(f),s.handle(t,r);if(e.canHandle(t))return o.add(f),e.handle(t,r);if(n.canHandle(t))return o.add(f),n.handle(t,r)}return!r.filterOut&&(f++,!0)}));return o.forEach((t=>{const i=t-1,s=b.exec(l[i]),e=p.exec(l[t]);null!==s&&null!==e&&(l[i]=l[i].replace(b,((...t)=>t.every((t=>/^[\r\n]+$/.test(t))))(s[1],e[1])?s[1]:""),l[t]=l[t].replace(p,""))})),l.join("")}m.if=s,m.elseif=e,m.else=n,m.endif=r,m.switch=a,m.case=u,m.default=d,m.endswitch=w,m.always=E;export{h as ConditionalTagSyntaxError,m as _,E as _always,u as _case,d as _default,n as _else,e as _elseif,r as _endif,w as _endswitch,s as _if,a as _switch};
