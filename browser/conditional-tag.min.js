/* conditional-tag v1.1.0
https://github.com/VividVisions/conditional-tag */
const t=Symbol("condTrue"),e=Symbol("condFalse");function i(i){return{func:"if",cond:i?t:e}}function s(i){return{func:"elseif",cond:i?t:e}}const n=Symbol("else"),r=Symbol("endif");class c extends Error{}class h{static steps={NEUTRAL:0,IF:1,ELSEIF:2,ELSE:3};withinIf;anyCondMet;step;constructor(){this.#t()}#t(){this.withinIf=!1,this.anyCondMet=!1,this.step=h.NEUTRAL}#e(t){return"if"===t?.func&&(this.#i(t?.cond)||this.#s(t?.cond))}#n(t){return"elseif"===t?.func&&(this.#i(t?.cond)||this.#s(t?.cond))}#r(t){return t===n}#c(t){return t===r}#i(e){return e===t}#s(t){return t===e}canHandle(t){return this.#e(t)||this.#n(t)||this.#r(t)||this.#c(t)}handle(t,e){if(this.#e(t)){if(this.withinIf)throw new c("Only one _if() permitted per if-block.");this.anyCondMet=this.#i(t.cond),e.filterOut=!this.anyCondMet,this.step=h.steps.IF,this.withinIf=!0}else if(this.#n(t)){if(!this.withinIf)throw new c("_elseif() must be inside if-block.");if(this.step>h.steps.ELSEIF)throw new c("_elseif() must not occur after _else.");this.step=h.steps.ELSEIF,this.anyCondMet?e.filterOut=!0:(this.anyCondMet=this.#i(t.cond),e.filterOut=!this.anyCondMet)}else if(this.#r(t)){if(!this.withinIf)throw new c("_else must be inside if-block.");if(this.step>h.steps.ELSEIF)throw new c("Only one _else permitted per if-block.");this.step=h.steps.ELSE,this.anyCondMet?e.filterOut=!0:(e.filterOut=!1,this.anyCondMet=!0)}else if(this.#c(t)){if(!this.withinIf)throw new c("_endif must be inside if-block.");this.#t(),e.filterOut=!1}return!1}}const o=Symbol("switch"),a=Symbol("case"),f=Symbol("switchCase");function l(t){return{func:o,switchVar:t,_case:y(t)}}function u(...t){return{func:a,caseVars:t}}const d=Symbol("default"),w=Symbol("endswitch");function y(t){return function(...e){return{func:f,switchVar:t,caseVars:e}}}class p{switchVar;anyCondMet;constructor(){this.#t()}#t(){this.switchVar=void 0,this.anyCondMet=!1}#h(t){return t?.func===o}#o(t){return t?.func===a}#a(t){return t?.func===f}#f(t){return t===d}#l(t){return t===w}canHandle(t){return this.#h(t)||this.#o(t)||this.#a(t)||this.#f(t)||this.#l(t)}handle(t,e){if(this.#h(t)){if(void 0!==this.switchVar)throw new c("Only one _switch() permitted per switch-block.");this.switchVar=t.switchVar}else if(this.#a(t)){if(void 0!==this.switchVar)throw new c("Only one _switch() permitted per switch-block.");this.switchVar=t.switchVar,t.func=a}if(this.#o(t)){if(void 0===this.switchVar)throw new c("_case() must be inside switch-block.");t.caseVars.some((t=>t===this.switchVar))?(this.anyCondMet=!0,e.filterOut=!1):e.filterOut=!0}else if(this.#f(t)){if(void 0===this.switchVar)throw new c("_default must be inside switch-block.");e.filterOut=this.anyCondMet}else if(this.#l(t)){if(void 0===this.switchVar)throw new c("_endswitch must be inside switch-block");e.filterOut=!1,this.#t()}return!1}}const m=Symbol("always");class E{canHandle(t){return t===m}handle(t,e){return e.filterOut=!1,!1}}function S(t){return"function"==typeof t&&void 0===t.prototype&&""===t.name}class b{canHandle(t){return S(t)}handle(t,e){e.filterOut||(t[Symbol.toPrimitive]=function(){return this()})}}const C=/(^|\r?\n)[^\S\r\n]*$/,I=/^[^\S\r\n]*(\r?\n|$)/,O=/^[\r\n]+$/,V=(...t)=>t.every((t=>O.test(t)));function M(t,e){return t.flatMap(((t,i)=>i<e.length?[t,e[i]]:t))}function _(t){const e=new h,i=new p,s=new E,n=new b,r={filterOut:!1},c=new Set;let o=0;return{output:t.filter(((t,h)=>{if("string"!=typeof t){if(e.canHandle(t))return c.add(o),e.handle(t,r);if(i.canHandle(t))return c.add(o),i.handle(t,r);if(s.canHandle(t))return c.add(o),s.handle(t,r);n.canHandle(t)&&n.handle(t,r)}return!r.filterOut&&(o++,!0)})),handled:c}}function k(t,e){e.forEach((e=>{const i=e-1,s=C.exec(t[i]),n=I.exec(t[e]);null!==s&&null!==n&&(t[i]=t[i].replace(C,V(s[1],n[1])?s[1]:""),t[e]=t[e].replace(I,""))}))}function v(t,...e){const i=M(t,e);try{const{output:t,handled:e}=_(i);return k(t,e),t.join("")}catch(t){if(t instanceof TypeError)throw new Error(`${t.message} (Maybe there's an async function in an expression? Use tag function _.a with await.)`,{cause:t});throw t}}async function F(t,...e){const i=M(t,e),{output:s,handled:n}=_(i),r=await Promise.all(s.map((t=>S(t)?t[Symbol.toPrimitive]():t)));return k(r,n),r.join("")}v.if=i,v.async=F,v.elseif=s,v.else=n,v.endif=r,v.switch=l,v.case=u,v.default=d,v.endswitch=w,v.always=m;export{c as ConditionalTagSyntaxError,v as _,m as _always,F as _async,u as _case,d as _default,n as _else,s as _elseif,r as _endif,w as _endswitch,i as _if,l as _switch};
